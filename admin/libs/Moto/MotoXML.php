<?php
class MotoXML extends DOMDocument { const NO_CACHE = 0; const CACHE_ALLOW = 1; const RELOAD = 2; const XML_VERSION = "1.0"; const XML_ENCODING = "UTF-8"; private static $cache = array(); private $source = ""; private $_xpath; public static function create($source = "", $caching = self::CACHE_ALLOW ) { $source = str_replace('\\', '/', realpath($source)); if ( (!empty($source)) && ($caching == self::CACHE_ALLOW || $caching == self::RELOAD) ) { $md5 = md5(strtolower($source)); if (!isset(self::$cache[$md5]) || $caching == self::RELOAD) { self::$cache[$md5] = new MotoXML($source); } return self::$cache[$md5]; } return new MotoXML($source); } public function __construct($source = '', $version = self::XML_VERSION, $encoding = self::XML_ENCODING) { parent::__construct($version, $encoding); if (is_string($source)) $source = trim($source); $this->source = $source; $this->formatOutput = true; $this->preserveWhitespace = false; if (!empty($source)) { if (!file_exists($source)) { $info = pathinfo($source); $dir = str_replace(MOTO_DOCUMENT_ROOT . MOTO_ROOT_URL, "", str_replace("\\", "/", realpath($info["dirname"]))) . "/"; echo "<pre><b>Error</b>: Required file \"{$dir}" . $info["basename"]. "\" could not be found. Please check you uploaded all the files."; die(); } libxml_use_internal_errors(true); libxml_clear_errors(); $this->load($source); if (self::isLibXMLErrors()) { if( self::repairXML($source) ) { $this->load($source); } else { $message = self::returnLibXMLErrors($source, libxml_get_errors()); if ($message != '' && is_string($message)) MotoLog::getInstance()->err($message); throw new Exception($message); } } } } private static function isLibXMLErrors() { $result = false; if (count(libxml_get_errors())>0) { foreach(libxml_get_errors() as $error) { switch ($error->level) { case LIBXML_ERR_WARNING: break; case LIBXML_ERR_ERROR: $result = true; break; case LIBXML_ERR_FATAL: $result = true; break; } } } return $result; } private static function returnLibXMLErrors($source, $errors = array()) { $message = ""; if (count($errors) <1 ) $errors = libxml_get_errors(); if (count($errors) >0 ) foreach($errors as $error) { switch ($error->level) { case LIBXML_ERR_WARNING: $message .= 'Warning in file ' . basename($source) . ', line ' . $error->line . ' column ' . $error->column . ': ' . $error->message; break; case LIBXML_ERR_ERROR: if ($error->line > 0 && $error->column >0) $message .= 'Error in file ' . basename($source) . ', line ' . $error->line . ' column ' . $error->column . ': ' . $error->message; break; case LIBXML_ERR_FATAL: if ($error->line > 0 && $error->column >0) $message .= 'Fatal Error in file ' . basename($source) . ', line ' . $error->line . ' column ' . $error->column . ': ' . $error->message; break; } } return $message; } public static function repairXML($filename) { MotoUtil::quickRepairXML($filename); libxml_clear_errors(); $dom = new DOMDocument("1.0", "UTF-8"); $dom->formatOutput = true; $dom->preserveWhitespace = false; $dom->load($filename); if (!count(libxml_get_errors())>0) return true; $errors = libxml_get_errors(); $actions = array("KILL_SYMBOLS" => array(), "KILL_SYMBOLS_CHR" => array()); $iactions = 0; foreach($errors as $error) { switch ($error->code) { case 9: if (preg_match("/ ([0-9]+)$/i", $error->message, $match)) { if (!isset($actions["KILL_SYMBOLS"][$match[1]])) { $actions["KILL_SYMBOLS"][$match[1]] = false; $actions["KILL_SYMBOLS_CHR"][] = chr($match[1]); $symbols .= $match[1]."\n"; } $iactions++; } break; } } if ($iactions == 0) return false; if (filesize($filename) < 500*1024) { $data = file_get_contents($filename); if (isset($actions["KILL_SYMBOLS"]) && count($actions["KILL_SYMBOLS"]) > 0) { $data = str_replace($actions["KILL_SYMBOLS_CHR"], "", $data); } file_put_contents($filename, $data); } else { $newFilename = $filename . "." . microtime(1) . "-" . rand(10,100) . ".tmp"; if (@copy($filename, $newFilename)) { MotoUtil::fixFilePermission( $newFilename ); } else return false; $in = fopen($newFilename, "rb"); $out = fopen($filename, "wb"); while(!feof($in)) { $data = fread($in, 256*1024); if (isset($actions["KILL_SYMBOLS"]) && count($actions["KILL_SYMBOLS"]) > 0) { $data = str_replace($actions["KILL_SYMBOLS_CHR"], "", $data); } fwrite($out, $data); } fclose($in); fclose($out); MotoUtil::fixFilePermission( $filename ); @unlink($newFilename); } $data = ""; libxml_clear_errors(); $dom->load($filename); if (count(libxml_get_errors())>0) return false; return true; } private function getXPath() { if (!isset($this->_xpath)) { $this->_xpath = new DOMXPath($this); } return $this->_xpath; } public function query($query, DOMNode $context = null) { if (is_null($context)) { return $this->getXPath()->query($query); } else { return $this->getXPath()->query($query, $context); } } public static function findByXPath($query, DOMNode $context, $className = '', $findOne = false) { $dom = ($context instanceof DOMDocument) ? $context : $context->ownerDocument; $context = ($context instanceof DOMDocument) ? $context->documentElement : $context; $result = $dom->query($query, $context); if (!empty($className)) { $result = self::wrapNodesWithObjects($result, $className); } if ($findOne) { $result = empty($className) ? $result->item(0) : (reset($result) === false ? null : $result[0]); } return $result; } public static function findOneByXPath($query, DOMNode $context, $className = '') { return self::findByXPath($query, $context, $className, true); } public static function wrapNodesWithObjects(DOMNodeList $nodeList, $className) { if (!class_exists($className)) { throw new Exception("Class \"{$className}\" does not exist"); } if (!(new $className instanceof MotoDomObjectInterface)) { throw new Exception("Class \"{$className}\" should implement \"MotoDomObjectInterface\" interface"); } $objectList = array(); foreach ($nodeList as $node) { $object = new $className; $objectList[] = $object->loadDomElement($node); } return $objectList; } public static function getXML($file) { $dom = new self(); if (!$dom->load($file)) { MotoLog::getInstance()->err('Can not load file: '.$file); throw new Exception('Can not load file: '.$file); } return $dom; } public static function putXML(DOMDocument $dom, $file, $check = true) { if ($check) { $user = new UserService(); if (!$user->isAuthenticated()->status->status) { MotoLog::getInstance()->err('Access denied.'); throw new Exception('Access denied.', StatusEnum::ERROR_ACCESS_DENIED); } } $backupMode = ''; if (defined('BACKUP_AUTO_MODE') && BACKUP_AUTO_MODE == 'true') { $backupMode = 'quick'; $backupDir = MOTO_ADMIN_DIR . '/_tmp/backup/'; $fileInfo = pathinfo($file); MotoUtil::createDir( $backupDir ); if ( !is_dir($backupDir) || !is_writable($backupDir) ) $backupMode = ''; } if ($backupMode == 'quick') { $backupFileName = $fileInfo['filename'] . '-' .date('Y-m-d-H-is', time()); $dumpFileName = $backupFileName . '.dump'; $badFileName = $backupFileName . '.bad'; $backupFileName .= '.' . $fileInfo['extension']; if (!@copy($file, $backupDir . $backupFileName)) $backupMode = ''; } if (!$dom->save($file)) { MotoLog::getInstance()->err('Can not save file: ' . $file); throw new Exception('Can not save file: ' . $file); } MotoUtil::fixFilePermission( $file ); $checkDom = new DOMDocument(); $checkDom->load($file); if (count(libxml_get_errors())>0) { $message = self::returnLibXMLErrors($file, libxml_get_errors()); MotoLog::getInstance()->err($message); if (!self::repairXML($file)) { if ( $backupMode == 'quick' && file_exists($backupDir . '/' . $backupFileName) ) { $ok = rename($file, $backupDir . $badFileName); @file_put_contents($backupDir . $dumpFileName, base64_encode(serialize($_SESSION)) . "\n" . base64_encode(serialize($_COOKIE)) . "\n" . base64_encode(@file_get_contents('php://input')) ); if ($ok) $ok &= copy($backupDir . '/' . $backupFileName, $file); if ($ok) $message = 'Warning: Content data is corrupted and your changes will not be saved.'; else $message = 'Error: Content data is corrupted and can not be restored.'; $message = 'MotoXML: ' . $message . ' See admin/_tmp/backup.'; } MotoLog::getInstance()->err($message); throw new Exception($message); } } if ( $backupMode == 'quick' && file_exists($backupDir . '/' . $backupFileName) ) @unlink($backupDir . '/' . $backupFileName); try { MotoCache::getInstance()->clean(MotoCache::CLEANING_MODE_ALL); } catch (Exception $e) { MotoLog::getInstance()->err('MotoXML: Unable to clean cache.'); } } } 