<?php
class Moto_Html_HelpRender extends sfTemplateHelper { protected $_renders = array(); protected $_engine = null; static protected $_instance = null; static protected $_requirements = array(); protected $_response = array(); protected $_content = null; public function __construct() { self::$_instance = $this; $this->_init(); } protected function _init() { } static function getInstance() { if (self::$_instance == null) self::$_instance = new self(); return self::$_instance; } public function getName() { return 'htmlHelpRender'; } function assign($name, $value) { $this->_response[$name] = $value; } public function getResponse() { return $this->_response; } function get($name, $default = '') { if ($this->_engine == null) $this->_engine = $this->helperSet->getEngine(); return $this->_engine->get($name, $default); } function getRender($name) { if (!preg_match('/^[a-z]+$/i', $name)) { return null; } if (!isset($this->_renders[$name])) { $class = 'Moto_Html_Render_' . ucfirst($name); if (class_exists($class)) $this->_renders[$name] = new $class($this); else $this->_renders[$name] = null; } return $this->_renders[$name]; } function getContent() { return $this->_content; } function dispatch($content, $type) { $this->_content = $content; $html = ''; if ($type == 'page') { $html .= $this->_renderHolders($content->website); $html .= $this->_renderHolders($content->layout); } $html .= $this->_renderHolders($content->{$type}); return $html; } protected function _renderHolders($content) { if ($content == null) return ''; $html = ''; $render = $this->getRender('holder'); if (isset($content->holders) && $content->holders != null) foreach($content->holders as $holder_id => $holder) { $html .= $render->proccess($holder, $content); } return $html; } public function renderLoginForm($content) { $render = $this->getRender('LoginForm'); $html = ''; if ($render != null) { $html .= $render->proccess($content); } return $html; } protected function _renderWebsite($content) { $html = ''; return $html; } protected function _renderLayout($content) { $html = ''; return $html; } protected function _renderPage($content) { $html = ''; return $html; } function holders() { $holders = $this->get('holders'); if (!is_array($holders)) return ''; $html = ''; foreach($holders as $id => $holder) { $html .= $this->holder($holder->id); } return $html; } public function holder($holder) { if (!is_object($holder)) { $holders = $this->get('holders'); if (!is_array($holders) || !isset($holders[$holder]) ) return ''; $holder = $holders[$holder]; } $html = ''; $render = $this->getRender('holder'); if ($render != null) { $html = $render->proccess($holder); } return $html; } static function addRequirements($item) { $item['type'] = strtolower($item['type']); if (!isset(self::$_requirements[$item['type']])) self::$_requirements[$item['type']] = array(); self::$_requirements[$item['type']][] = $item; } function initJavascripts($_this) { if ( !isset(self::$_requirements['js']) ) return; foreach(self::$_requirements['js'] as $i => $item) { if (!$item['defer']) { $_this->javascripts->add($item['file']); self::$_requirements['js'][$i] = null; } } } function initStylesheets($_this) { if ( !isset(self::$_requirements['css']) ) return; foreach(self::$_requirements['css'] as $i => $item) { $_this->stylesheets->add($item['file']); self::$_requirements['css'][$i] = null; } } function loadDeferJavascripts() { $html = ''; if ( !isset(self::$_requirements['js']) ) return; foreach(self::$_requirements['js'] as $item) if ($item != null) { if ($item['defer']) { $html .= "
<script type=\"text/javascript\">
(function() {
	var js = document.createElement('script');
	js.type = 'text/javascript';
	js.async = true;
	js.src = '".$this->helperSet->get('assets')->getUrl($item['file'])."';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(js);
})();
</script>
"; } } return $html; } function getStyles($content, $propName, $echo = false) { $styles = ''; try { if (isset($content->website->properties[$propName])) $styles = $content->website->properties[$propName]['value']; } catch (Exception $e){} if ($echo) { echo $styles; } return $styles; } function getImg($content, $propName, $basePath, $echo = false) { $img = array( 'value' => '', 'width' => 0, 'height' => 0, ); try { $prop = $content->website->properties[$propName]; if ($prop) { $img['value'] = $prop['value']; if ($prop['image']) { $img['width'] = $prop['image']->parameters['width']; $img['height'] = $prop['image']->parameters['height']; if (strpos($img['value'], '/') > 0) { $img['value'] = $basePath . $img['value']; } } } } catch (Exception $e){} if ($echo) { if (strlen($img['value']) > 0) { echo 'background-image: url(' .$img['value']. ');'; echo 'background-position: 50% 50%;'; echo 'background-repeat: no-repeat;'; } if ($img['width'] > 0) { echo 'min-width: ' . $img['width'] . 'px;'; } } return $img; } function getOpacity($content, $propName, $echo = false) { $opacity = (int)$this->getStyles($content, $propName); if ($echo) { echo 'opacity: ' . (0.01*$opacity) . ' !important;'; echo 'filter: alpha(opacity=' . $opacity . ') !important;'; } return $opacity; } function getColor($content, $propName) { $color = $this->getStyles($content, $propName); if (!$color) { $color = '000000'; } return '#' . $color; } function addFonts($fonts) { $maxCount = 5; $currentCount = 0; $packPart = 0; $googleWebFonts = array(); $googleWebFontsdefaults = array( 'family' => array(), 'subset' => array(), 'href' => '' ); for($i = 0, $icount = count($fonts); $i < $icount; $i++) { $font = $fonts[$i]; if (!isset($googleWebFonts[$packPart])) { $googleWebFonts[$packPart] = $googleWebFontsdefaults; } if ($font->isGoogle && $font->enabled) { $fontFamily = str_replace(' ', '+', $font->name) . ':n'; if ($font->bold) $fontFamily .= ',b'; if ($font->italic) $fontFamily .= ',i'; if ($font->boldItalic) $fontFamily .= ',bi'; $googleWebFonts[$packPart]['family'][] = $fontFamily; $characters = $font->characters; if ($characters == 'default') $characters = 'cyrillic,cyrillic-ext,greek,greek-ext,latin,latin-ext'; $subsets = str_replace('-extended', '-ext', str_replace(' ', '', $characters)); $subsets = explode(',', $subsets); for($iSubset = 0, $iSubsetCount = count($subsets); $iSubset < $iSubsetCount; $iSubset++) { $googleWebFonts[$packPart]['subset'][ $subsets[$iSubset] ] = $subsets[$iSubset]; } $currentCount ++; if ($maxCount > 0 && $currentCount >= $maxCount) { $packPart ++; $currentCount = 0; } } else { $this->addFont($font); } } if (!empty($googleWebFonts[0]) && !empty($googleWebFonts[0]['family'])) { for($i = 0, $icount = count($googleWebFonts); $i < $icount; $i++) { $googleWebFonts[$i]['family'] = implode('|', $googleWebFonts[$i]['family']); $googleWebFonts[$i]['subset'] = implode(',', $googleWebFonts[$i]['subset']); $googleWebFonts[$i]['href'] = '//fonts.googleapis.com/css?family=' . $googleWebFonts[$i]['family'] . '&subset=' . $googleWebFonts[$i]['subset']; $item = array( 'type' => 'css', 'file' => $googleWebFonts[$i]['href'] ); $this->addRequirements($item); } } } function addFont($font) { if ($font->isGoogle && $font->enabled) { $file = '//fonts.googleapis.com/css?family=' . str_replace(' ', '+', $font->name) . ':n'; if ($font->bold) $file .= ',b'; if ($font->italic) $file .= ',i'; if ($font->boldItalic) $file .= ',bi'; $characters = $font->characters; if ($characters == 'default') $characters = 'cyrillic,cyrillic-ext,greek,greek-ext,latin,latin-ext'; $file .= '&subset=' . str_replace('-extended', '-ext', str_replace(' ', '', $characters)); $item = array( 'type' => 'css', 'file' => $file ); $this->addRequirements($item); } } } 