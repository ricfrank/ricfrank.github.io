<?php
class MotoXML extends DOMDocument { const NO_CACHE = 0; const CACHE_ALLOW = 1; const RELOAD = 2; const XML_VERSION = "1.0"; const XML_ENCODING = "UTF-8"; private static $cache = array(); private $source = ""; private $_xpath; public static function create($source = "", $caching = self::CACHE_ALLOW ) { $source = str_replace('\\', '/', realpath($source)); if ( (!empty($source)) && ($caching == self::CACHE_ALLOW || $caching == self::RELOAD) ) { $md5 = md5(strtolower($source)); if (!isset(self::$cache[$md5]) || $caching == self::RELOAD) { self::$cache[$md5] = new MotoXML($source); } return self::$cache[$md5]; } return new MotoXML($source); } public function __construct($source = '', $version = self::XML_VERSION, $encoding = self::XML_ENCODING) { parent::__construct($version, $encoding); $this->source = $source; $this->formatOutput = true; $this->preserveWhitespace = false; if (!empty($source)) { if (!file_exists($source)) { $info = pathinfo($source); $dir = str_replace(MOTO_DOCUMENT_ROOT . MOTO_ROOT_URL, "", str_replace("\\", "/", realpath($info["dirname"]))) . "/"; die("<pre><b>Error</b>: Required file \"{$dir}" . $info["basename"]. "\" could not be found. Please check you uploaded all the files."); } libxml_use_internal_errors(true); $this->load($source); if (count(libxml_get_errors())>0) MotoLog::getInstance()->err(self::returnLibXMLErrors($source, libxml_get_errors())); if (self::isLibXMLErrors()) { if( self::repairXML($source) ) { $this->load($source); } else { $message = self::returnLibXMLErrors($source, libxml_get_errors()); MotoLog::getInstance()->err($message); throw new Exception($message); } } } } private static function isLibXMLErrors() { $result = false; if (count(libxml_get_errors())>0) { foreach(libxml_get_errors() as $error) { switch ($error->level) { case LIBXML_ERR_WARNING: break; case LIBXML_ERR_ERROR: $result = true; break; case LIBXML_ERR_FATAL: $result = true; break; } } } return $result; } private static function returnLibXMLErrors($source, $errors = array()) { $message = ""; if (count($errors) <1 ) $errors = libxml_get_errors(); if (count($errors) >0 ) foreach($errors as $error) { switch ($error->level) { case LIBXML_ERR_WARNING: $message .= "Warning in file " . basename($source) . ", line " . $error->line . " column " . $error->column . ": " . $error->message; break; case LIBXML_ERR_ERROR: $message .= "Fatal Error in file " . basename($source) . ", line " . $error->line . " column " . $error->column . ": " . $error->message; break; case LIBXML_ERR_FATAL: $message .= "Fatal Error in file " . basename($source) . ", line " . $error->line . " column " . $error->column . ": " . $error->message; break; } } return $message; } public static function repairXML($filename) { MotoUtil::quickRepairXML($filename); libxml_clear_errors(); $dom = new DOMDocument("1.0", "UTF-8"); $dom->formatOutput = true; $dom->preserveWhitespace = false; $dom->load($filename); if (!count(libxml_get_errors())>0) return true; $errors = libxml_get_errors(); $actions = array("KILL_SYMBOLS" => array(), "KILL_SYMBOLS_CHR" => array()); $iactions = 0; foreach($errors as $error) { switch ($error->code) { case 9: if (preg_match("/ ([0-9]+)$/i", $error->message, $match)) { if (!isset($actions["KILL_SYMBOLS"][$match[1]])) { $actions["KILL_SYMBOLS"][$match[1]] = false; $actions["KILL_SYMBOLS_CHR"][] = chr($match[1]); $symbols .= $match[1]."\n"; } $iactions++; } break; } } if ($iactions == 0) return false; if (filesize($filename) < 500*1024) { $data = file_get_contents($filename); if (isset($actions["KILL_SYMBOLS"]) && count($actions["KILL_SYMBOLS"]) > 0) { $data = str_replace($actions["KILL_SYMBOLS_CHR"], "", $data); } file_put_contents($filename, $data); } else { $newFilename = $filename . "." . microtime(1) . "-" . rand(10,100) . ".tmp"; if (@copy($filename, $newFilename)) { @chmod($newFilename, 0644); } else return false; $in = fopen($newFilename, "rb"); $out = fopen($filename, "wb"); while(!feof($in)) { $data = fread($in, 256*1024); if (isset($actions["KILL_SYMBOLS"]) && count($actions["KILL_SYMBOLS"]) > 0) { $data = str_replace($actions["KILL_SYMBOLS_CHR"], "", $data); } fwrite($out, $data); } fclose($in); fclose($out); @chmod($filename, 0644); @unlink($newFilename); } $data = ""; libxml_clear_errors(); $dom->load($filename); if (count(libxml_get_errors())>0) return false; return true; } private function getXPath() { if (!isset($this->_xpath)) { $this->_xpath = new DOMXPath($this); } return $this->_xpath; } public function query($query, DOMNode $context = null) { if (is_null($context)) { return $this->getXPath()->query($query); } else { return $this->getXPath()->query($query, $context); } } public static function findByXPath($query, DOMNode $context, $className = '', $findOne = false) { $dom = ($context instanceof DOMDocument) ? $context : $context->ownerDocument; $context = ($context instanceof DOMDocument) ? $context->documentElement : $context; $result = $dom->query($query, $context); if (!empty($className)) { $result = self::wrapNodesWithObjects($result, $className); } if ($findOne) { $result = empty($className) ? $result->item(0) : (reset($result) === false ? null : $result[0]); } return $result; } public static function findOneByXPath($query, DOMNode $context, $className = '') { return self::findByXPath($query, $context, $className, true); } public static function wrapNodesWithObjects(DOMNodeList $nodeList, $className) { if (!class_exists($className)) { throw new Exception("Class \"{$className}\" does not exist"); } if (!(new $className instanceof MotoDomObjectInterface)) { throw new Exception("Class \"{$className}\" should implement \"MotoDomObjectInterface\" interface"); } $objectList = array(); foreach ($nodeList as $node) { $object = new $className; $objectList[] = $object->loadDomElement($node); } return $objectList; } public static function getXML($file) { $dom = new self(); if (!$dom->load($file)) { MotoLog::getInstance()->err('Can not load file: '.$file); throw new Exception('Can not load file: '.$file); } return $dom; } public static function putXML(DOMDocument $dom, $file, $check = true) { if ($check) { $user = new UserService(); if (!$user->isAuthenticated()->status->status) { MotoLog::getInstance()->err('Access denied.'); throw new Exception('Access denied.'); } } if (!$dom->save($file)) { MotoLog::getInstance()->err('Can not save file: '.$file); throw new Exception('Can not save file: '.$file); } if (substr(sprintf('%o', fileperms($file)), -4)*1<644) @chmod($file, 0644); $checkDom = new DOMDocument(); $checkDom->load($file); if (count(libxml_get_errors())>0) MotoLog::getInstance()->err(self::returnLibXMLErrors($file, libxml_get_errors())); if (self::isLibXMLErrors()) self::repairXML($file); } }